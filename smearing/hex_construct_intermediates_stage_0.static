static void construct_intermediates_stage_0(stout_notes_outer *trace, su3_outer *const V, gauge_field_t const U, su3_outer *const smeared_force)
{
  _Complex double ALIGN mat_trace;
  su3 ALIGN t1;
  su3 ALIGN t2;
  
  #define _CONSTRUCT_INTERMEDIATE_COMPONENT(component, principal, x) \
  { \
    _su3d_times_su3(trace[x][component].Sigma, V[x][component], smeared_force[x][component]); \
    /* t2 == Tr[U * Sigma * B2] * A */ \
    _su3_times_su3(t1, trace[x][component].Sigma, trace[x][component].B2); \
    _trace_su3_times_su3(mat_trace, U[x][principal], t1); \
    _complex_times_su3(t2, mat_trace, trace[x][component].A); \
    /* Z == (Tr[U * Sigma * B1] + Tr[U * Sigma * B2] * A ) * A */ \
    _su3_times_su3(t1, trace[x][component].Sigma, trace[x][component].B1); \
    _trace_su3_times_su3(mat_trace, U[x][principal], t1); \
    _su3_add_equals_complex_identity(t2, mat_trace); \
    _su3_times_su3(trace[x][component].Z, t2, trace[x][component].A); \
    /* Z == (Tr[U * Sigma * B1] + Tr[U * Sigma * B2] * A ) * A  + f_1 * U * Sigma */ \
    _su3_times_su3(t1, U[x][principal], trace[x][component].Sigma); \
    _complex_times_su3(t2, trace[x][component].f1, t1); \
    _su3_plus_su3(trace[x][component].Z, t2, trace[x][component].Z); \
    /* Z == (Tr[U * Sigma * B1] + Tr[U * Sigma * B2] * A ) * A  + f_1 * U * Sigma - i * f2 * U * Sigma * A */ \
    _su3_times_su3(t2, t1, trace[x][component].A); \
    _complex_times_su3(t2, trace[x][component].f2, t2); \
    _su3_plus_su3(trace[x][component].Z, t2, trace[x][component].Z); \
    /* t1 == (Tr[U * Sigma * B1] + Tr[U * Sigma * B2] * A ) * A  + f_1 * U * Sigma + f2 * ( U * Sigma * A + A * U * Sigma ) */ \
    _su3_times_su3(t2, trace[x][component].A, t1); \
    _complex_times_su3(t2, trace[x][component].f2, t2); \
    _su3_plus_su3(t1, t2, trace[x][component].Z); \
    /* Z = U^\dagger * P_TA(t1) == Z */ \
    project_traceless_antiherm(&t1); \
    _su3d_times_su3(trace[x][component].Z, U[x][principal], t1); \
  }
  
#pragma omp for private(mat_trace, t1, t2)
  for (unsigned int x = 0; x < VOLUME; ++x)
  {
    _CONSTRUCT_INTERMEDIATE_COMPONENT(I2_0_12, I0_0, x);
    _CONSTRUCT_INTERMEDIATE_COMPONENT(I2_0_13, I0_0, x);
    _CONSTRUCT_INTERMEDIATE_COMPONENT(I2_0_23, I0_0, x);
    
    _CONSTRUCT_INTERMEDIATE_COMPONENT(I2_1_02, I0_1, x);
    _CONSTRUCT_INTERMEDIATE_COMPONENT(I2_1_03, I0_1, x);
    _CONSTRUCT_INTERMEDIATE_COMPONENT(I2_1_23, I0_1, x);
    
    _CONSTRUCT_INTERMEDIATE_COMPONENT(I2_2_01, I0_2, x);
    _CONSTRUCT_INTERMEDIATE_COMPONENT(I2_2_03, I0_2, x);
    _CONSTRUCT_INTERMEDIATE_COMPONENT(I2_2_13, I0_2, x);
    
    _CONSTRUCT_INTERMEDIATE_COMPONENT(I2_3_01, I0_3, x);
    _CONSTRUCT_INTERMEDIATE_COMPONENT(I2_3_02, I0_3, x);
    _CONSTRUCT_INTERMEDIATE_COMPONENT(I2_3_12, I0_3, x);
  }
  
#pragma omp single
  generic_exchange(&trace, sizeof(stout_notes_tuple));
  
  #undef _CONSTRUCT_INTERMEDIATE_COMPONENT
}
